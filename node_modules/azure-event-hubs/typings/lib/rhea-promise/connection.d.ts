import * as rhea from "rhea";
import { Session } from "./session";
import { Sender, SenderOptions } from "./sender";
import { Receiver, ReceiverOptions } from "./receiver";
import { ConnectionEvents } from ".";
export interface SenderOptionsWithSession extends SenderOptions {
    session?: Session;
}
export interface ReceiverOptionsWithSession extends ReceiverOptions {
    session?: Session;
}
export interface ReqResLink {
    sender: Sender;
    receiver: Receiver;
    session: Session;
}
export declare class Connection {
    options?: rhea.ConnectionOptions;
    private _connection;
    constructor(options?: rhea.ConnectionOptions);
    readonly id: string;
    /**
     * Creates a new amqp connection.
     * @param {ConnectionOptions} [options] Options to be provided for establishing an amqp connection.
     * @return {Promise<Connection>} Promise<Connection>
     * - **Resolves** the promise with the Connection object when rhea emits the "connection_open" event.
     * - **Rejects** the promise with an AmqpError when rhea emits the "connection_close" event while trying
     * to establish an amqp connection.
     */
    open(): Promise<Connection>;
    /**
     * Closes the amqp connection.
     * @return {Promise<void>} Promise<void>
     * - **Resolves** the promise when rhea emits the "connection_close" event.
     * - **Rejects** the promise with an AmqpError when rhea emits the "connection_error" event while trying
     * to close an amqp connection.
     */
    close(): Promise<void>;
    /**
     * Determines whether the connection is open.
     * @return {boolean} true if open false otherwise.
     */
    isOpen(): boolean;
    /**
     * Determines whether the close from the peer is a response to a locally initiated close request
     * for the connection.
     * @returns {boolean} `true` if close was locally initiated, `false` otherwise.
     */
    wasCloseInitiated(): boolean;
    /**
     * Creates an amqp session on the provided amqp connection.
     * @return {Promise<Session>} Promise<Session>
     * - **Resolves** the promise with the Session object when rhea emits the "session_open" event.
     * - **Rejects** the promise with an AmqpError when rhea emits the "session_close" event while trying
     * to create an amqp session.
     */
    createSession(): Promise<Session>;
    /**
     * Creates an amqp sender link. It either uses the provided session or creates a new one.
     * @param {SenderOptionsWithSession} options Optional parameters to create a sender link.
     * @return {Promise<Sender>} Promise<Sender>.
     */
    createSender(options?: SenderOptionsWithSession): Promise<Sender>;
    /**
     * Creates an amqp receiver link. It either uses the provided session or creates a new one.
     * @param {ReceiverOptionsWithSession} options Optional parameters to create a receiver link.
     * @return {Promise<Receiver>} Promise<Receiver>.
     */
    createReceiver(options?: ReceiverOptionsWithSession): Promise<Receiver>;
    /**
     * Creates an amqp sender-receiver link. It either uses the provided session or creates a new one.
     * This method creates a sender-receiver link on the same session. It is useful for management
     * style operations where one may want to send a request and await for response.
     * @param {SenderOptions} senderOptions Parameters to create a sender.
     * @param {ReceiverOptions} receiverOptions Parameters to create a receiver.
     * @param {Session} [session] The optional session on which the sender and receiver links will be
     * created.
     * @return {Promise<ReqResLink>} Promise<ReqResLink>
     */
    createRequestResponseLink(senderOptions: SenderOptions, receiverOptions: ReceiverOptions, providedSession?: Session): Promise<ReqResLink>;
    registerHandler(event: ConnectionEvents, handler: rhea.OnAmqpEvent): void;
    removeHandler(event: ConnectionEvents, handler: rhea.OnAmqpEvent): void;
}
