/// <reference types="node" />
import * as rhea from "rhea";
import { Session } from "./session";
import { Connection } from "./connection";
import { SenderEvents } from ".";
export interface SenderOptions extends rhea.SenderOptions {
    onAccepted?: rhea.OnAmqpEvent;
    onRejected?: rhea.OnAmqpEvent;
    onReleased?: rhea.OnAmqpEvent;
    onModified?: rhea.OnAmqpEvent;
    onError?: rhea.OnAmqpEvent;
    onClose?: rhea.OnAmqpEvent;
    onSessionError?: rhea.OnAmqpEvent;
    onSessionClose?: rhea.OnAmqpEvent;
}
export declare class Sender {
    senderOptions?: SenderOptions;
    private _session;
    private _sender;
    constructor(session: Session, sender: rhea.Sender, options?: SenderOptions);
    readonly name: string;
    readonly error: rhea.AmqpError | Error | undefined;
    readonly properties: rhea.Dictionary<any>;
    readonly source: rhea.Source;
    readonly target: rhea.TerminusOptions;
    readonly address: string;
    readonly credit: number;
    readonly session: Session;
    readonly connection: Connection;
    /**
     * Determines whether the message is sendable.
     * @returns {boolean} `true` Sendable. `false` Not Sendable.
     */
    sendable(): boolean;
    send(msg: rhea.Message | Buffer, tag?: Buffer | string, format?: number): rhea.Delivery;
    /**
     * Determines whether the sender link is open.
     * @returns {boolean} `true` open. `false` closed.
     */
    isOpen(): boolean;
    /**
     * Determines whether both local and remote endpoint for link or it's underlying session
     * or it's underlying connection are closed.
     * Within the "sender_close", "session_close" event handler, if this
     * method returns `false` it means that the local end is still open. It can be useful to
     * determine whether the close was initiated locally under such circumstances.
     *
     * @returns {boolean} `true` if closed, `false` otherwise.
     */
    isClosed(): boolean;
    /**
     * Determines whether both local and remote endpoint for just the link itself are closed.
     * Within the "sender_close" event handler, if this method returns `false` it
     * means that the local end is still open. It can be useful to determine whether the close
     * was initiated locally under such circumstances.
     *
     * @returns {boolean} `true` - closed, `false` otherwise.
     */
    isItselfClosed(): boolean;
    /**
     * Determines whether both local and remote endpoint for session or it's underlying
     * connection are closed.
     *
     * Within the "session_close" event handler, if this method returns `false` it means that
     * the local end is still open. It can be useful to determine whether the close
     * was initiated locally under such circumstances.
     *
     * @returns {boolean} `true` - closed, `false` otherwise.
     */
    isSessionClosed(): boolean;
    /**
     * Determines whether both local and remote endpoint for just the session itself are closed.
     * Within the "session_close" event handler, if this method returns `false` it means that
     * the local end is still open. It can be useful to determine whether the close
     * was initiated locally under such circumstances.
     *
     * @returns {boolean} `true` - closed, `false` otherwise.
     */
    isSessionItselfClosed(): boolean;
    /**
     * Removes the sender and it's underlying session from the internal map.
     * @returns {void} void
     */
    remove(): void;
    /**
     * Closes the amqp sender.
     * @return {Promise<void>} Promise<void>
     * - **Resolves** the promise when rhea emits the "sender_close" event.
     * - **Rejects** the promise with an AmqpError when rhea emits the
     * "sender_error" event while trying to close an amqp sender.
     */
    close(): Promise<void>;
    setMaxListeners(count: number): void;
    getMaxListeners(): number;
    registerHandler(event: SenderEvents, handler: rhea.OnAmqpEvent): void;
    removeHandler(event: SenderEvents, handler: rhea.OnAmqpEvent): void;
    registerSessionHandler(event: rhea.SessionEvents, handler: rhea.OnAmqpEvent): void;
    removeSessionHandler(event: rhea.SessionEvents, handler: rhea.OnAmqpEvent): void;
}
