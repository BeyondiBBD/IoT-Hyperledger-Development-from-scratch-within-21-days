import * as rhea from "rhea";
import { Session } from "./session";
import { Connection } from "./connection";
import { ReceiverEvents } from ".";
export interface ReceiverOptions extends rhea.ReceiverOptions {
    onMessage?: rhea.OnAmqpEvent;
    onError?: rhea.OnAmqpEvent;
    onClose?: rhea.OnAmqpEvent;
    onSessionError?: rhea.OnAmqpEvent;
    onSessionClose?: rhea.OnAmqpEvent;
}
export declare class Receiver {
    receiverOptions?: ReceiverOptions;
    private _session;
    private _receiver;
    constructor(session: Session, receiver: rhea.Receiver, options?: ReceiverOptions);
    readonly name: string;
    readonly error: rhea.AmqpError | Error | undefined;
    readonly properties: rhea.Dictionary<any>;
    readonly source: rhea.Source;
    readonly target: rhea.TerminusOptions;
    readonly address: string;
    readonly session: Session;
    readonly connection: Connection;
    readonly drain: boolean;
    addCredit(credit: number): void;
    setCreditWindow(creditWindow: number): void;
    /**
     * Determines whether the receiver link is open.
     * @returns {boolean} `true` open. `false` closed.
     */
    isOpen(): boolean;
    /**
     * Determines whether both local and remote endpoint for link or it's underlying session
     * or it's underlying connection are closed.
     * Within the "receiver_close", "session_close" event handler, if this
     * method returns `false` it means that the local end is still open. It can be useful to
     * determine whether the close was initiated locally under such circumstances.
     *
     * @returns {boolean} `true` if closed, `false` otherwise.
     */
    isClosed(): boolean;
    /**
     * Determines whether both local and remote endpoint for just the link itself are closed.
     * Within the "receiver_close" event handler, if this method returns `false` it
     * means that the local end is still open. It can be useful to determine whether the close
     * was initiated locally under such circumstances.
     *
     * @returns {boolean} `true` - closed, `false` otherwise.
     */
    isItselfClosed(): boolean;
    /**
     * Determines whether both local and remote endpoint for session or it's underlying
     * connection are closed.
     *
     * Within the "session_close" event handler, if this method returns `false` it means that
     * the local end is still open. It can be useful to determine whether the close
     * was initiated locally under such circumstances.
     *
     * @returns {boolean} `true` - closed, `false` otherwise.
     */
    isSessionClosed(): boolean;
    /**
     * Determines whether both local and remote endpoint for just the session itself are closed.
     * Within the "session_close" event handler, if this method returns `false` it means that
     * the local end is still open. It can be useful to determine whether the close
     * was initiated locally under such circumstances.
     *
     * @returns {boolean} `true` - closed, `false` otherwise.
     */
    isSessionItselfClosed(): boolean;
    /**
     * Removes the receiver and it's underlying session from the internal map.
     * @returns {void} void
     */
    remove(): void;
    /**
     * Closes the amqp receiver.
     * @return {Promise<void>} Promise<void>
     * - **Resolves** the promise when rhea emits the "receiver_close" event.
     * - **Rejects** the promise with an AmqpError when rhea emits the
     * "receiver_error" event while trying to close an amqp receiver.
     */
    close(): Promise<void>;
    registerHandler(event: ReceiverEvents, handler: rhea.OnAmqpEvent): void;
    removeHandler(event: ReceiverEvents, handler: rhea.OnAmqpEvent): void;
    registerSessionHandler(event: rhea.SessionEvents, handler: rhea.OnAmqpEvent): void;
    removeSessionHandler(event: rhea.SessionEvents, handler: rhea.OnAmqpEvent): void;
}
