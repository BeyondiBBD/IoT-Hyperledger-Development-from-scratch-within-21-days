"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const errors_1 = require("./errors");
const _1 = require(".");
const log = require("./log");
const constants_1 = require("./util/constants");
/**
 * Determines whether the object is a Delivery object.
 * @ignore
 */
function isDelivery(obj) {
    let result = false;
    if (obj && typeof obj.id === "number" && typeof obj.settled === "boolean" &&
        typeof obj.remote_settled === "boolean" && typeof obj.format === "number") {
        result = true;
    }
    return result;
}
/**
 * Describes the retry operation type.
 * @enum RetryOperationType
 */
var RetryOperationType;
(function (RetryOperationType) {
    RetryOperationType["cbsAuth"] = "cbsAuth";
    RetryOperationType["connection"] = "connection";
    RetryOperationType["management"] = "management";
    RetryOperationType["receiverLink"] = "receiverLink";
    RetryOperationType["senderLink"] = "senderLink";
    RetryOperationType["sendMessage"] = "sendMessage";
    RetryOperationType["session"] = "session";
})(RetryOperationType = exports.RetryOperationType || (exports.RetryOperationType = {}));
/**
 * Validates the retry config.
 * @ignore
 */
function validateRetryConfig(config) {
    if (!config.operation || typeof config.operation !== "function") {
        throw new Error("'operation' is a required property and must be of type 'function' " +
            "that returns a Promise.");
    }
    if (!config.connectionId || typeof config.connectionId !== "string") {
        throw new Error("'connectionId' is a required property and must be of type 'string'.");
    }
    if (!config.operationType || typeof config.operationType !== "string") {
        throw new Error("'operationType' is a required property and must be of type 'string'.");
    }
    if (config.times && typeof config.times !== "number") {
        throw new Error("'times' must be of type 'number'.");
    }
    if (config.delayInSeconds && typeof config.delayInSeconds !== "number") {
        throw new Error("'delayInSeconds' must be of type 'number'.");
    }
}
/**
 * It will attempt to linearly retry an operation specified number of times with a specified
 * delay in between each retry. The retries will only happen if the error is retryable.
 *
 * @param {RetryConfig<T>} config Parameters to configure retry operation.
 *
 * @return {Promise<T>} Promise<T>.
 */
async function retry(config) {
    validateRetryConfig(config);
    if (config.times == undefined)
        config.times = constants_1.defaultRetryAttempts;
    if (config.delayInSeconds == undefined)
        config.delayInSeconds = constants_1.defaultDelayBetweenRetriesInSeconds;
    let lastError;
    let result;
    let success = false;
    for (let i = 0; i < config.times; i++) {
        const j = i + 1;
        log.retry("[%s] Retry for '%s', attempt number: %d", config.connectionId, config.operationType, j);
        try {
            result = await config.operation();
            success = true;
            log.retry("[%s] Success for '%s', after attempt number: %d.", config.connectionId, config.operationType, j);
            if (result && !isDelivery(result)) {
                log.retry("[%s] Success result for '%s': %O", config.connectionId, config.operationType, result);
            }
            break;
        }
        catch (err) {
            if (!err.translated) {
                err = errors_1.translate(err);
            }
            lastError = err;
            log.error("[%s] Error occured for '%s' in attempt number %d: %O", config.connectionId, config.operationType, j, err);
            if (lastError && lastError.retryable) {
                log.error("[%s] Sleeping for %d seconds for '%s'.", config.connectionId, config.delayInSeconds, config.operationType);
                await _1.delay(config.delayInSeconds * 1000);
                continue;
            }
            else {
                break;
            }
        }
    }
    if (success) {
        return result;
    }
    else {
        throw lastError;
    }
}
exports.retry = retry;
//# sourceMappingURL=retry.js.map