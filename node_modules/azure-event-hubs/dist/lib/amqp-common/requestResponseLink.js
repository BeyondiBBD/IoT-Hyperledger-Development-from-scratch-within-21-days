"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const uuid = require("uuid/v4");
const Constants = require("./util/constants");
const retry_1 = require("./retry");
const rhea_promise_1 = require("../rhea-promise");
const errors_1 = require("./errors");
const log = require("./log");
/**
 * Describes an amqp request(sender)-response(receiver) link that is created over an amqp session.
 * @class RequestResponseLink
 */
class RequestResponseLink {
    /**
     * @constructor
     * @param {Session} session The amqp session.
     * @param {Sender} sender The amqp sender link.
     * @param {Receiver} receiver The amqp receiver link.
     */
    constructor(session, sender, receiver) {
        this.session = session;
        this.sender = sender;
        this.receiver = receiver;
        this.session = session;
        this.sender = sender;
        this.receiver = receiver;
    }
    /**
     * Provides the underlying amqp connection object.
     * @returns {Connection} Connection.
     */
    get connection() {
        return this.session.connection;
    }
    /**
     * Indicates whether the session and the sender and receiver links are all open or closed.
     * @returns {boolean} boolean - `true` - `open`, `false` - `closed`.
     */
    isOpen() {
        return this.session.isOpen() && this.sender.isOpen() && this.receiver.isOpen();
    }
    /**
     * Sends the given request message and returns the received response. If the operation is not
     * completed in the provided timeout in seconds `default: 10`, then the request will be retried
     * linearly for the provided number of times `default: 3` with the provided delay in seconds
     * `default: 15` between each attempt.
     *
     * @param {Message} request The AMQP message.
     * @param {SendRequestOptions} [options] Options that can be provided while sending a request.
     * @returns {Promise<T>} Promise<T>
     */
    sendRequest(request, options) {
        if (!request) {
            throw new Error("request is a required parameter and must be of type 'object'.");
        }
        if (!request.message_id)
            request.message_id = uuid();
        if (!options)
            options = {};
        if (!options.timeoutInSeconds) {
            options.timeoutInSeconds = 10;
        }
        const sendRequestPromise = new Promise((resolve, reject) => {
            let waitTimer;
            let timeOver = false;
            const messageCallback = (context) => {
                // remove the event listener as this will be registered next time when someone makes a request.
                this.receiver.removeHandler(rhea_promise_1.ReceiverEvents.message, messageCallback);
                const code = context.message.application_properties[Constants.statusCode];
                const desc = context.message.application_properties[Constants.statusDescription];
                const errorCondition = context.message.application_properties[Constants.errorCondition];
                const responseCorrelationId = context.message.correlation_id;
                log.reqres("[%s] %s response: ", this.connection.id, request.to || "$management", context.message);
                if (code > 199 && code < 300) {
                    if (request.message_id === responseCorrelationId || request.correlation_id === responseCorrelationId) {
                        if (!timeOver) {
                            clearTimeout(waitTimer);
                        }
                        log.reqres("[%s] request-messageId | '%s' == '%s' | response-correlationId.", this.connection.id, request.message_id, responseCorrelationId);
                        return resolve(context.message.body);
                    }
                    else {
                        log.error("[%s] request-messageId | '%s' != '%s' | response-correlationId. " +
                            "Hence dropping this response and waiting for the next one.", this.connection.id, request.message_id, responseCorrelationId);
                    }
                }
                else {
                    const condition = errorCondition || errors_1.ConditionStatusMapper[code] || "amqp:internal-error";
                    const e = {
                        condition: condition,
                        description: desc
                    };
                    const error = errors_1.translate(e);
                    log.error(error);
                    return reject(error);
                }
            };
            const actionAfterTimeout = () => {
                timeOver = true;
                this.receiver.removeHandler(rhea_promise_1.ReceiverEvents.message, messageCallback);
                const address = this.receiver.address || "address";
                const desc = `The request with message_id "${request.message_id}" to "${address}" ` +
                    `endpoint timed out. Please try again later.`;
                const e = {
                    condition: errors_1.ConditionStatusMapper[408],
                    description: desc
                };
                return reject(errors_1.translate(e));
            };
            this.receiver.registerHandler(rhea_promise_1.ReceiverEvents.message, messageCallback);
            waitTimer = setTimeout(actionAfterTimeout, options.timeoutInSeconds * 1000);
            log.reqres("[%s] %s request sent: %O", this.connection.id, request.to || "$managment", request);
            this.sender.send(request);
        });
        const config = {
            operation: () => sendRequestPromise,
            connectionId: this.connection.id,
            operationType: request.to && request.to === Constants.cbsEndpoint
                ? retry_1.RetryOperationType.cbsAuth
                : retry_1.RetryOperationType.management,
            delayInSeconds: options.delayInSeconds,
            times: options.times
        };
        return retry_1.retry(config);
    }
    /**
     * Closes the sender, receiver link and the underlying session.
     * @returns {Promise<void>} Promise<void>
     */
    async close() {
        await this.sender.close();
        await this.receiver.close();
        await this.session.close();
    }
    /**
     * Creates an amqp request/response link.
     *
     * @param {Connection} connection The amqp connection.
     * @param {SenderOptions} senderOptions Options that must be provided to create the sender link.
     * @param {ReceiverOptions} receiverOptions Options that must be provided to create the receiver link.
     * @returns {Promise<RequestResponseLink>} Promise<RequestResponseLink>
     */
    static async create(connection, senderOptions, receiverOptions) {
        if (!connection) {
            throw new Error(`Please provide a connection to create the sender/receiver link on the same session.`);
        }
        if (!senderOptions) {
            throw new Error(`Please provide sender options.`);
        }
        if (!receiverOptions) {
            throw new Error(`Please provide receiver options.`);
        }
        const session = await connection.createSession();
        const sender = await session.createSender(senderOptions);
        const receiver = await session.createReceiver(receiverOptions);
        log.reqres("[%s] Successfully created the sender and receiver links on the same session.", connection.id);
        return new RequestResponseLink(session, sender, receiver);
    }
}
exports.RequestResponseLink = RequestResponseLink;
//# sourceMappingURL=requestResponseLink.js.map