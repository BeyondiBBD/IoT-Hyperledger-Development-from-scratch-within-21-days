"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const AsyncLock = require("async-lock");
/**
 * Parses the connection string and returns an object of type T.
 * @param {string} connectionString The connection string to be parsed.
 * @returns {ParsedOutput<T>} ParsedOutput<T>.
 */
function parseConnectionString(connectionString) {
    return connectionString.split(';').reduce((acc, part) => {
        const splitIndex = part.indexOf('=');
        return Object.assign({}, acc, { [part.substring(0, splitIndex)]: part.substring(splitIndex + 1) });
    }, {});
}
exports.parseConnectionString = parseConnectionString;
/**
 * Gets a new instance of the async lock with desired settings.
 * @param {AsyncLockOptions} [options] The async lock options.
 * @returns {AsyncLock} AsyncLock
 */
function getNewAsyncLock(options) {
    return new AsyncLock(options);
}
exports.getNewAsyncLock = getNewAsyncLock;
/**
 * @constant {AsyncLock} defaultLock The async lock instance with default settings.
 */
exports.defaultLock = new AsyncLock({ maxPending: 10000 });
/**
 * Describes a Timeout class that can wait for the specified amount of time and then resolve/reject
 * the promise with the given value.
 * @class Timout
 */
class Timeout {
    set(t, value) {
        const self = this;
        return new Promise((resolve) => {
            self._timer = setTimeout(() => resolve(value), t);
        });
    }
    clear() {
        if (this._timer) {
            clearTimeout(this._timer);
        }
    }
    wrap(promise, t, value) {
        const wrappedPromise = this._promiseFinally(promise, () => this.clear());
        const timer = this.set(t, value);
        return Promise.race([wrappedPromise, timer]);
    }
    _promiseFinally(promise, fn) {
        const success = (result) => {
            fn();
            return result;
        };
        const error = (e) => {
            fn();
            return Promise.reject(e);
        };
        return Promise.resolve(promise).then(success, error);
    }
    static set(t, value) {
        return new Timeout().set(t, value);
    }
    static wrap(promise, t, value) {
        return new Timeout().wrap(promise, t, value);
    }
}
exports.Timeout = Timeout;
/**
 * A wrapper for setTimeout that resolves a promise after t milliseconds.
 * @param {number} t - The number of milliseconds to be delayed.
 * @param {T} value - The value to be resolved with after a timeout of t milliseconds.
 * @returns {Promise<T>} - Resolved promise
 */
function delay(t, value) {
    return new Promise((resolve) => setTimeout(() => resolve(value), t));
}
exports.delay = delay;
/**
 * Generates a random number between the given interval
 * @param {number} min Min number of the range (inclusive).
 * @param {number} max Max number of the range (inclusive).
 */
function randomNumberFromInterval(min, max) {
    return Math.floor(Math.random() * (max - min + 1) + min);
}
exports.randomNumberFromInterval = randomNumberFromInterval;
/*
 * Executes an array of promises sequentially. Inspiration of this method is here:
 * https://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html. An awesome blog on promises!
 *
 * @param {Array} promiseFactories An array of promise factories(A function that return a promise)
 *
 * @param {any} [kickstart] Input to the first promise that is used to kickstart the promise chain.
 * If not provided then the promise chain starts with undefined.
 *
 * @return A chain of resolved or rejected promises
 */
function executePromisesSequentially(promiseFactories, kickstart) {
    let result = Promise.resolve(kickstart);
    promiseFactories.forEach((promiseFactory) => {
        result = result.then(promiseFactory);
    });
    return result;
}
exports.executePromisesSequentially = executePromisesSequentially;
/**
 * Determines whether the given connection string is an iothub connection string.
 * @param {string} connectionString The connection string.
 * @return {boolean} boolean.
 */
function isIotHubConnectionString(connectionString) {
    if (!connectionString || typeof connectionString !== "string") {
        throw new Error("connectionString is a required parameter and must be of type string.");
    }
    let result = false;
    const model = parseConnectionString(connectionString);
    if (model && model.HostName && model.SharedAccessKey && model.SharedAccessKeyName) {
        result = true;
    }
    return result;
}
exports.isIotHubConnectionString = isIotHubConnectionString;
//# sourceMappingURL=utils.js.map