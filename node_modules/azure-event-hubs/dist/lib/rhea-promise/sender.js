"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const log = require("./log");
const _1 = require(".");
const constants_1 = require("./util/constants");
class Sender {
    constructor(session, sender, options) {
        this._session = session;
        this._sender = sender;
        this.senderOptions = options;
    }
    get name() {
        return this._sender.name;
    }
    get error() {
        return this._sender.error;
    }
    get properties() {
        return this._sender.properties;
    }
    get source() {
        return this._sender.source;
    }
    get target() {
        return this._sender.target;
    }
    get address() {
        return this.source.address;
    }
    get credit() {
        return this._sender.credit;
    }
    get session() {
        return this._session;
    }
    get connection() {
        return this._session.connection;
    }
    /**
     * Determines whether the message is sendable.
     * @returns {boolean} `true` Sendable. `false` Not Sendable.
     */
    sendable() {
        return this._sender.sendable();
    }
    send(msg, tag, format) {
        return this._sender.send(msg, tag, format);
    }
    /**
     * Determines whether the sender link is open.
     * @returns {boolean} `true` open. `false` closed.
     */
    isOpen() {
        let result = false;
        if (this._session.isOpen() && this._sender.is_open()) {
            result = true;
        }
        return result;
    }
    /**
     * Determines whether both local and remote endpoint for link or it's underlying session
     * or it's underlying connection are closed.
     * Within the "sender_close", "session_close" event handler, if this
     * method returns `false` it means that the local end is still open. It can be useful to
     * determine whether the close was initiated locally under such circumstances.
     *
     * @returns {boolean} `true` if closed, `false` otherwise.
     */
    isClosed() {
        return this._sender.is_closed();
    }
    /**
     * Determines whether both local and remote endpoint for just the link itself are closed.
     * Within the "sender_close" event handler, if this method returns `false` it
     * means that the local end is still open. It can be useful to determine whether the close
     * was initiated locally under such circumstances.
     *
     * @returns {boolean} `true` - closed, `false` otherwise.
     */
    isItselfClosed() {
        return this._sender.is_itself_closed();
    }
    /**
     * Determines whether both local and remote endpoint for session or it's underlying
     * connection are closed.
     *
     * Within the "session_close" event handler, if this method returns `false` it means that
     * the local end is still open. It can be useful to determine whether the close
     * was initiated locally under such circumstances.
     *
     * @returns {boolean} `true` - closed, `false` otherwise.
     */
    isSessionClosed() {
        return this._session.isClosed();
    }
    /**
     * Determines whether both local and remote endpoint for just the session itself are closed.
     * Within the "session_close" event handler, if this method returns `false` it means that
     * the local end is still open. It can be useful to determine whether the close
     * was initiated locally under such circumstances.
     *
     * @returns {boolean} `true` - closed, `false` otherwise.
     */
    isSessionItselfClosed() {
        return this._session.isItselfClosed();
    }
    /**
     * Removes the sender and it's underlying session from the internal map.
     * @returns {void} void
     */
    remove() {
        if (this._sender) {
            this._sender.remove();
        }
        if (this._session) {
            this._session.remove();
        }
    }
    /**
     * Closes the amqp sender.
     * @return {Promise<void>} Promise<void>
     * - **Resolves** the promise when rhea emits the "sender_close" event.
     * - **Rejects** the promise with an AmqpError when rhea emits the
     * "sender_error" event while trying to close an amqp sender.
     */
    close() {
        const senderClose = new Promise((resolve, reject) => {
            log.error("[%s] The sender is open ? -> %s", this.connection.id, this.isOpen());
            if (this.isOpen()) {
                let onError;
                let onClose;
                let waitTimer;
                const removeListeners = () => {
                    clearTimeout(waitTimer);
                    this._sender.removeListener(_1.SenderEvents.senderError, onError);
                    this._sender.removeListener(_1.SenderEvents.senderClose, onClose);
                };
                onClose = (context) => {
                    removeListeners();
                    process.nextTick(() => {
                        log.sender("[%s] Resolving the promise as the amqp sender has been closed.", this.connection.id);
                        resolve();
                    });
                };
                onError = (context) => {
                    removeListeners();
                    log.error("[%s] Error occurred while closing amqp sender: %O.", this.connection.id, context.session.error);
                    reject(context.session.error);
                };
                const actionAfterTimeout = () => {
                    removeListeners();
                    const msg = `Unable to close the amqp sender ${this.name} due to operation timeout.`;
                    log.error("[%s] %s", this.connection.id, msg);
                    reject(new Error(msg));
                };
                this._sender.once(_1.SenderEvents.senderClose, onClose);
                this._sender.once(_1.SenderEvents.senderError, onError);
                waitTimer = setTimeout(actionAfterTimeout, constants_1.defaultOperationTimeoutInSeconds * 1000);
                this._sender.close();
            }
            else {
                resolve();
            }
        });
        return senderClose.then(() => {
            log.sender("[%s] sender has been closed, now closing it's session.", this.connection.id);
            return this._session.close();
        });
    }
    setMaxListeners(count) {
        this._sender.setMaxListeners(count);
    }
    getMaxListeners() {
        return this._sender.getMaxListeners();
    }
    registerHandler(event, handler) {
        this._sender.on(event, handler);
    }
    removeHandler(event, handler) {
        this._sender.removeListener(event, handler);
    }
    registerSessionHandler(event, handler) {
        this._session.registerHandler(event, handler);
    }
    removeSessionHandler(event, handler) {
        this._session.removeHandler(event, handler);
    }
}
exports.Sender = Sender;
//# sourceMappingURL=sender.js.map