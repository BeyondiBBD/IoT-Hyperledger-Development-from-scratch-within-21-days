"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const log = require("./log");
const _1 = require(".");
const constants_1 = require("./util/constants");
class Receiver {
    constructor(session, receiver, options) {
        this._session = session;
        this._receiver = receiver;
        this.receiverOptions = options;
    }
    get name() {
        return this._receiver.name;
    }
    get error() {
        return this._receiver.error;
    }
    get properties() {
        return this._receiver.properties;
    }
    get source() {
        return this._receiver.source;
    }
    get target() {
        return this._receiver.target;
    }
    get address() {
        return this.source.address;
    }
    get session() {
        return this._session;
    }
    get connection() {
        return this._session.connection;
    }
    get drain() {
        return this._receiver.drain;
    }
    addCredit(credit) {
        this._receiver.add_credit(credit);
    }
    setCreditWindow(creditWindow) {
        this._receiver.set_credit_window(creditWindow);
    }
    /**
     * Determines whether the receiver link is open.
     * @returns {boolean} `true` open. `false` closed.
     */
    isOpen() {
        let result = false;
        if (this._session.isOpen() && this._receiver.is_open()) {
            result = true;
        }
        return result;
    }
    /**
     * Determines whether both local and remote endpoint for link or it's underlying session
     * or it's underlying connection are closed.
     * Within the "receiver_close", "session_close" event handler, if this
     * method returns `false` it means that the local end is still open. It can be useful to
     * determine whether the close was initiated locally under such circumstances.
     *
     * @returns {boolean} `true` if closed, `false` otherwise.
     */
    isClosed() {
        return this._receiver.is_closed();
    }
    /**
     * Determines whether both local and remote endpoint for just the link itself are closed.
     * Within the "receiver_close" event handler, if this method returns `false` it
     * means that the local end is still open. It can be useful to determine whether the close
     * was initiated locally under such circumstances.
     *
     * @returns {boolean} `true` - closed, `false` otherwise.
     */
    isItselfClosed() {
        return this._receiver.is_itself_closed();
    }
    /**
     * Determines whether both local and remote endpoint for session or it's underlying
     * connection are closed.
     *
     * Within the "session_close" event handler, if this method returns `false` it means that
     * the local end is still open. It can be useful to determine whether the close
     * was initiated locally under such circumstances.
     *
     * @returns {boolean} `true` - closed, `false` otherwise.
     */
    isSessionClosed() {
        return this._session.isClosed();
    }
    /**
     * Determines whether both local and remote endpoint for just the session itself are closed.
     * Within the "session_close" event handler, if this method returns `false` it means that
     * the local end is still open. It can be useful to determine whether the close
     * was initiated locally under such circumstances.
     *
     * @returns {boolean} `true` - closed, `false` otherwise.
     */
    isSessionItselfClosed() {
        return this._session.isItselfClosed();
    }
    /**
     * Removes the receiver and it's underlying session from the internal map.
     * @returns {void} void
     */
    remove() {
        if (this._receiver) {
            this._receiver.remove();
        }
        if (this._session) {
            this._session.remove();
        }
    }
    /**
     * Closes the amqp receiver.
     * @return {Promise<void>} Promise<void>
     * - **Resolves** the promise when rhea emits the "receiver_close" event.
     * - **Rejects** the promise with an AmqpError when rhea emits the
     * "receiver_error" event while trying to close an amqp receiver.
     */
    close() {
        const receiverClose = new Promise((resolve, reject) => {
            log.error("[%s] The receiver is open ? -> %s", this.connection.id, this.isOpen());
            if (this.isOpen()) {
                let onError;
                let onClose;
                let waitTimer;
                const removeListeners = () => {
                    clearTimeout(waitTimer);
                    this._receiver.removeListener(_1.ReceiverEvents.receiverError, onError);
                    this._receiver.removeListener(_1.ReceiverEvents.receiverClose, onClose);
                };
                onClose = (context) => {
                    removeListeners();
                    process.nextTick(() => {
                        log.receiver("[%s] Resolving the promise as the amqp receiver has been closed.", this.connection.id);
                        resolve();
                    });
                };
                onError = (context) => {
                    removeListeners();
                    log.error("[%s] Error occurred while closing amqp receiver. %O", this.connection.id, context.session.error);
                    reject(context.session.error);
                };
                const actionAfterTimeout = () => {
                    removeListeners();
                    const msg = `Unable to close the amqp receiver ${this.name} due to operation timeout.`;
                    log.error("[%s] %s", this.connection.id, msg);
                    reject(new Error(msg));
                };
                this._receiver.once(_1.ReceiverEvents.receiverClose, onClose);
                this._receiver.once(_1.ReceiverEvents.receiverError, onError);
                waitTimer = setTimeout(actionAfterTimeout, constants_1.defaultOperationTimeoutInSeconds * 1000);
                this._receiver.close();
            }
            else {
                resolve();
            }
        });
        return receiverClose.then(() => {
            log.receiver("[%s] receiver has been closed, now closing it's session.", this.connection.id);
            return this._session.close();
        });
    }
    registerHandler(event, handler) {
        this._receiver.on(event, handler);
    }
    removeHandler(event, handler) {
        this._receiver.removeListener(event, handler);
    }
    registerSessionHandler(event, handler) {
        this._session.registerHandler(event, handler);
    }
    removeSessionHandler(event, handler) {
        this._session.removeHandler(event, handler);
    }
}
exports.Receiver = Receiver;
//# sourceMappingURL=receiver.js.map