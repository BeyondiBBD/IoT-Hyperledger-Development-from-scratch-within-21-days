"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const log = require("./log");
const receiver_1 = require("./receiver");
const sender_1 = require("./sender");
const _1 = require(".");
const constants_1 = require("./util/constants");
class Session {
    constructor(connection, session) {
        this._connection = connection;
        this._session = session;
    }
    get connection() {
        return this._connection;
    }
    get outgoing() {
        return this._session.outgoing;
    }
    isOpen() {
        let result = false;
        if (this._connection.isOpen() && this._session.is_open()) {
            result = true;
        }
        return result;
    }
    /**
     * Determines whether the close from the peer is a response to a locally initiated close request.
     * @returns {boolean} `true` if close was locally initiated, `false` otherwise.
     */
    isClosed() {
        return this._session.is_closed();
    }
    /**
     * Determines whether both local and remote endpoint for just the session itself are closed.
     * Within the "session_close" event handler, if this method returns `false` it means that
     * the local end is still open. It can be useful to determine whether the close
     * was initiated locally under such circumstances.
     *
     * @returns {boolean} `true` - closed, `false` otherwise.
     */
    isItselfClosed() {
        return this._session.is_itself_closed();
    }
    remove() {
        if (this._session) {
            this._session.remove();
        }
    }
    begin() {
        if (this._session) {
            this._session.begin();
        }
    }
    /**
     * Closes the amqp session.
     * @return {Promise<void>} Promise<void>
     * - **Resolves** the promise when rhea emits the "session_close" event.
     * - **Rejects** the promise with an AmqpError when rhea emits the "session_error" event while trying
     * to close an amqp session.
     */
    close() {
        return new Promise((resolve, reject) => {
            log.error("[%s] The session is open ? -> %s", this.connection.id, this.isOpen());
            if (this.isOpen()) {
                let onError;
                let onClose;
                let waitTimer;
                const removeListeners = () => {
                    clearTimeout(waitTimer);
                    this._session.removeListener(_1.SessionEvents.sessionError, onError);
                    this._session.removeListener(_1.SessionEvents.sessionClose, onClose);
                };
                onClose = (context) => {
                    removeListeners();
                    process.nextTick(() => {
                        log.session("[%s] Resolving the promise as the amqp session has been closed.", this.connection.id);
                        resolve();
                    });
                };
                onError = (context) => {
                    removeListeners();
                    log.error("[%s] Error occurred while closing amqp session.", this.connection.id, context.session.error);
                    reject(context.session.error);
                };
                const actionAfterTimeout = () => {
                    removeListeners();
                    const msg = `Unable to close the amqp session due to operation timeout.`;
                    log.error("[%s] %s", this.connection.id, msg);
                    reject(new Error(msg));
                };
                this._session.once(_1.SessionEvents.sessionClose, onClose);
                this._session.once(_1.SessionEvents.sessionError, onError);
                log.session("[%s] Calling session.close()", this.connection.id);
                waitTimer = setTimeout(actionAfterTimeout, constants_1.defaultOperationTimeoutInSeconds * 1000);
                this._session.close();
            }
            else {
                resolve();
            }
        });
    }
    /**
     * Creates an amqp receiver on this session.
     * @param {Session} session The amqp session object on which the receiver link needs to be established.
     * @param {ReceiverOptions} [options] Options that can be provided while creating an amqp receiver.
     * @return {Promise<Receiver>} Promise<Receiver>
     * - **Resolves** the promise with the Receiver object when rhea emits the "receiver_open" event.
     * - **Rejects** the promise with an AmqpError when rhea emits the "receiver_close" event while trying
     * to create an amqp receiver.
     */
    createReceiver(options) {
        if (options &&
            ((options.onMessage && !options.onError) || (options.onError && !options.onMessage))) {
            throw new Error("Both onMessage and onError handlers must be provided if one of " +
                "them is provided.");
        }
        const handlersProvided = options && options.onMessage ? true : false;
        return new Promise((resolve, reject) => {
            // Register session handlers for session_error and session_close if provided.
            if (options && options.onSessionError) {
                this._session.on(_1.SessionEvents.sessionError, options.onSessionError);
            }
            if (options && options.onSessionClose) {
                this._session.on(_1.SessionEvents.sessionClose, options.onSessionClose);
            }
            const rheaReceiver = this._session.attach_receiver(options);
            const receiver = new receiver_1.Receiver(this, rheaReceiver, options);
            let onOpen;
            let onClose;
            let waitTimer;
            if (handlersProvided) {
                rheaReceiver.on(_1.ReceiverEvents.message, options.onMessage);
                rheaReceiver.on(_1.ReceiverEvents.receiverError, options.onError);
            }
            if (options && options.onClose) {
                rheaReceiver.on(_1.ReceiverEvents.receiverClose, options.onClose);
            }
            const removeListeners = () => {
                clearTimeout(waitTimer);
                rheaReceiver.removeListener(_1.ReceiverEvents.receiverOpen, onOpen);
                rheaReceiver.removeListener(_1.ReceiverEvents.receiverClose, onClose);
            };
            onOpen = (context) => {
                removeListeners();
                process.nextTick(() => {
                    log.session("[%s] Resolving the promise with amqp receiver '%s'.", this.connection.id, rheaReceiver.name);
                    resolve(receiver);
                });
            };
            onClose = (context) => {
                removeListeners();
                log.error("[%s] Error occurred while creating a receiver over amqp connection: %O.", this.connection.id, context.receiver.error);
                reject(context.receiver.error);
            };
            const actionAfterTimeout = () => {
                removeListeners();
                const msg = `Unable to create the amqp receiver ${rheaReceiver.name} due to ` +
                    `operation timeout.`;
                log.error("[%s] %s", this.connection.id, msg);
                reject(new Error(msg));
            };
            rheaReceiver.once(_1.ReceiverEvents.receiverOpen, onOpen);
            rheaReceiver.once(_1.ReceiverEvents.receiverClose, onClose);
            waitTimer = setTimeout(actionAfterTimeout, constants_1.defaultOperationTimeoutInSeconds * 1000);
        });
    }
    /**
     * Creates an amqp sender on this session.
     * @param {SenderOptions} [options] Options that can be provided while creating an amqp sender.
     * @return {Promise<Sender>} Promise<Sender>
     * - **Resolves** the promise with the Sender object when rhea emits the "sender_open" event.
     * - **Rejects** the promise with an AmqpError when rhea emits the "sender_close" event while trying
     * to create an amqp sender.
     */
    createSender(options) {
        return new Promise((resolve, reject) => {
            // Register session handlers for session_error and session_close if provided.
            if (options && options.onSessionError) {
                this._session.on(_1.SessionEvents.sessionError, options.onSessionError);
            }
            if (options && options.onSessionClose) {
                this._session.on(_1.SessionEvents.sessionClose, options.onSessionClose);
            }
            const rheaSender = this._session.attach_sender(options);
            const sender = new sender_1.Sender(this, rheaSender, options);
            let onSendable;
            let onClose;
            let waitTimer;
            if (options) {
                if (options.onError) {
                    rheaSender.on(_1.SenderEvents.senderError, options.onError);
                }
                if (options.onClose) {
                    rheaSender.on(_1.SenderEvents.senderClose, options.onClose);
                }
                if (options.onAccepted) {
                    rheaSender.on(_1.SenderEvents.accepted, options.onAccepted);
                }
                if (options.onRejected) {
                    rheaSender.on(_1.SenderEvents.rejected, options.onRejected);
                }
                if (options.onReleased) {
                    rheaSender.on(_1.SenderEvents.released, options.onReleased);
                }
                if (options.onModified) {
                    rheaSender.on(_1.SenderEvents.modified, options.onModified);
                }
            }
            const removeListeners = () => {
                clearTimeout(waitTimer);
                rheaSender.removeListener(_1.SenderEvents.senderOpen, onSendable);
                rheaSender.removeListener(_1.SenderEvents.senderClose, onClose);
            };
            onSendable = (context) => {
                removeListeners();
                process.nextTick(() => {
                    log.session("[%s] Resolving the promise with amqp sender '%s'.", this.connection.id, rheaSender.name);
                    resolve(sender);
                });
            };
            onClose = (context) => {
                removeListeners();
                log.error("[%s] Error occurred while creating a sender over amqp connection: %O.", this.connection.id, context.sender.error);
                reject(context.sender.error);
            };
            const actionAfterTimeout = () => {
                removeListeners();
                const msg = `Unable to create the amqp sender ${rheaSender.name} due to ` +
                    `operation timeout.`;
                log.error("[%s] %s", this.connection.id, msg);
                reject(new Error(msg));
            };
            rheaSender.once(_1.SenderEvents.sendable, onSendable);
            rheaSender.once(_1.SenderEvents.senderClose, onClose);
            waitTimer = setTimeout(actionAfterTimeout, constants_1.defaultOperationTimeoutInSeconds * 1000);
        });
    }
    registerHandler(event, handler) {
        this._session.on(event, handler);
    }
    removeHandler(event, handler) {
        this._session.removeListener(event, handler);
    }
    registerConnectionHandler(event, handler) {
        this._connection.registerHandler(event, handler);
    }
    removeConnectionHandler(event, handler) {
        this._connection.removeHandler(event, handler);
    }
}
exports.Session = Session;
//# sourceMappingURL=session.js.map