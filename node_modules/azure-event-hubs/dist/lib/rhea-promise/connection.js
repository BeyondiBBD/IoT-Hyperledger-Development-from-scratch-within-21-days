"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const rhea = require("rhea");
const log = require("./log");
const session_1 = require("./session");
const _1 = require(".");
const constants_1 = require("./util/constants");
class Connection {
    constructor(options) {
        this.options = options;
        this._connection = rhea.create_connection(options);
    }
    get id() {
        return this._connection.options.id;
    }
    /**
     * Creates a new amqp connection.
     * @param {ConnectionOptions} [options] Options to be provided for establishing an amqp connection.
     * @return {Promise<Connection>} Promise<Connection>
     * - **Resolves** the promise with the Connection object when rhea emits the "connection_open" event.
     * - **Rejects** the promise with an AmqpError when rhea emits the "connection_close" event while trying
     * to establish an amqp connection.
     */
    open() {
        return new Promise((resolve, reject) => {
            if (!this.isOpen()) {
                let onOpen;
                let onClose;
                let waitTimer;
                const removeListeners = () => {
                    clearTimeout(waitTimer);
                    this._connection.removeListener(_1.ConnectionEvents.connectionOpen, onOpen);
                    this._connection.removeListener(_1.ConnectionEvents.connectionClose, onClose);
                    this._connection.removeListener(_1.ConnectionEvents.disconnected, onClose);
                };
                onOpen = (context) => {
                    removeListeners();
                    process.nextTick(() => {
                        log.connection("[%s] Resolving the promise with amqp connection.", this.id);
                        resolve(this);
                    });
                };
                onClose = (context) => {
                    removeListeners();
                    const err = context.error || context.connection.error;
                    log.error("[%s] Error occurred while establishing amqp connection: %O", this.id, err);
                    reject(err);
                };
                const actionAfterTimeout = () => {
                    removeListeners();
                    const msg = `Unable to open the amqp connection "${this.id}" due to operation timeout.`;
                    log.error("[%s] %s", this.id, msg);
                    reject(new Error(msg));
                };
                this._connection.once(_1.ConnectionEvents.connectionOpen, onOpen);
                this._connection.once(_1.ConnectionEvents.connectionClose, onClose);
                this._connection.once(_1.ConnectionEvents.disconnected, onClose);
                waitTimer = setTimeout(actionAfterTimeout, constants_1.defaultOperationTimeoutInSeconds * 1000);
                this._connection.connect();
            }
            else {
                resolve(this);
            }
        });
    }
    /**
     * Closes the amqp connection.
     * @return {Promise<void>} Promise<void>
     * - **Resolves** the promise when rhea emits the "connection_close" event.
     * - **Rejects** the promise with an AmqpError when rhea emits the "connection_error" event while trying
     * to close an amqp connection.
     */
    close() {
        return new Promise((resolve, reject) => {
            log.error("[%s] The connection is open ? -> %s", this.id, this.isOpen());
            if (this.isOpen()) {
                let onClose;
                let onError;
                let waitTimer;
                const removeListeners = () => {
                    clearTimeout(waitTimer);
                    this._connection.removeListener(_1.ConnectionEvents.connectionError, onError);
                    this._connection.removeListener(_1.ConnectionEvents.connectionClose, onClose);
                };
                onClose = (context) => {
                    removeListeners();
                    process.nextTick(() => {
                        log.connection("[%s] Resolving the promise as the connection has been successfully closed.", this.id);
                        resolve();
                    });
                };
                onError = (context) => {
                    removeListeners();
                    log.error("[%s] Error occurred while closing amqp connection: %O.", this.id, context.connection.error);
                    reject(context.connection.error);
                };
                const actionAfterTimeout = () => {
                    removeListeners();
                    const msg = `Unable to close the amqp connection "${this.id}" due to operation timeout.`;
                    log.error("[%s] %s", this.id, msg);
                    reject(new Error(msg));
                };
                this._connection.once(_1.ConnectionEvents.connectionClose, onClose);
                this._connection.once(_1.ConnectionEvents.connectionError, onError);
                waitTimer = setTimeout(actionAfterTimeout, constants_1.defaultOperationTimeoutInSeconds * 1000);
                this._connection.close();
            }
            else {
                resolve();
            }
        });
    }
    /**
     * Determines whether the connection is open.
     * @return {boolean} true if open false otherwise.
     */
    isOpen() {
        let result = false;
        if (this._connection && this._connection.is_open && this._connection.is_open()) {
            result = true;
        }
        return result;
    }
    /**
     * Determines whether the close from the peer is a response to a locally initiated close request
     * for the connection.
     * @returns {boolean} `true` if close was locally initiated, `false` otherwise.
     */
    wasCloseInitiated() {
        return this._connection.is_closed();
    }
    /**
     * Creates an amqp session on the provided amqp connection.
     * @return {Promise<Session>} Promise<Session>
     * - **Resolves** the promise with the Session object when rhea emits the "session_open" event.
     * - **Rejects** the promise with an AmqpError when rhea emits the "session_close" event while trying
     * to create an amqp session.
     */
    createSession() {
        return new Promise((resolve, reject) => {
            const rheaSession = this._connection.create_session();
            const session = new session_1.Session(this, rheaSession);
            let onOpen;
            let onClose;
            let waitTimer;
            const removeListeners = () => {
                clearTimeout(waitTimer);
                rheaSession.removeListener(_1.SessionEvents.sessionOpen, onOpen);
                rheaSession.removeListener(_1.SessionEvents.sessionClose, onClose);
            };
            onOpen = (context) => {
                removeListeners();
                process.nextTick(() => {
                    log.connection("[%s] Resolving the promise with amqp session.", this.id);
                    resolve(session);
                });
            };
            onClose = (context) => {
                removeListeners();
                log.error("[%s] Error occurred while establishing a session over amqp connection: %O.", this.id, context.session.error);
                reject(context.session.error);
            };
            const actionAfterTimeout = () => {
                removeListeners();
                const msg = `Unable to create the amqp session due to operation timeout.`;
                log.error("[%s] %s", this.id, msg);
                reject(new Error(msg));
            };
            rheaSession.once(_1.SessionEvents.sessionOpen, onOpen);
            rheaSession.once(_1.SessionEvents.sessionClose, onClose);
            log.connection("[%s] Calling amqp session.begin().", this.id);
            waitTimer = setTimeout(actionAfterTimeout, constants_1.defaultOperationTimeoutInSeconds * 1000);
            rheaSession.begin();
        });
    }
    /**
     * Creates an amqp sender link. It either uses the provided session or creates a new one.
     * @param {SenderOptionsWithSession} options Optional parameters to create a sender link.
     * @return {Promise<Sender>} Promise<Sender>.
     */
    async createSender(options) {
        if (options && options.session && options.session.createSender) {
            return await options.session.createSender(options);
        }
        const session = await this.createSession();
        return await session.createSender(options);
    }
    /**
     * Creates an amqp receiver link. It either uses the provided session or creates a new one.
     * @param {ReceiverOptionsWithSession} options Optional parameters to create a receiver link.
     * @return {Promise<Receiver>} Promise<Receiver>.
     */
    async createReceiver(options) {
        if (options && options.session && options.session.createReceiver) {
            return await options.session.createReceiver(options);
        }
        const session = await this.createSession();
        return await session.createReceiver(options);
    }
    /**
     * Creates an amqp sender-receiver link. It either uses the provided session or creates a new one.
     * This method creates a sender-receiver link on the same session. It is useful for management
     * style operations where one may want to send a request and await for response.
     * @param {SenderOptions} senderOptions Parameters to create a sender.
     * @param {ReceiverOptions} receiverOptions Parameters to create a receiver.
     * @param {Session} [session] The optional session on which the sender and receiver links will be
     * created.
     * @return {Promise<ReqResLink>} Promise<ReqResLink>
     */
    async createRequestResponseLink(senderOptions, receiverOptions, providedSession) {
        if (!senderOptions) {
            throw new Error(`Please provide sender options.`);
        }
        if (!receiverOptions) {
            throw new Error(`Please provide receiver options.`);
        }
        const session = providedSession || await this.createSession();
        const sender = await session.createSender(senderOptions);
        const receiver = await session.createReceiver(receiverOptions);
        log.connection("[%s] Successfully created the sender and receiver links on the same session.", this.id);
        return {
            session: session,
            sender: sender,
            receiver: receiver
        };
    }
    registerHandler(event, handler) {
        this._connection.on(event, handler);
    }
    removeHandler(event, handler) {
        this._connection.removeListener(event, handler);
    }
}
exports.Connection = Connection;
//# sourceMappingURL=connection.js.map