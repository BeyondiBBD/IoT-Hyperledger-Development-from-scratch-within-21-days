"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const uuid = require("uuid/v4");
const log = require("./log");
const rhea_promise_1 = require("./rhea-promise");
const amqp_common_1 = require("./amqp-common");
const eventData_1 = require("./eventData");
const linkEntity_1 = require("./linkEntity");
const eventPosition_1 = require("./eventPosition");
/**
 * Describes the EventHubReceiver that will receive event data from EventHub.
 * @class EventHubReceiver
 * @ignore
 */
class EventHubReceiver extends linkEntity_1.LinkEntity {
    /**
     * Instantiate a new receiver from the AMQP `Receiver`. Used by `EventHubClient`.
     * @ignore
     * @constructor
     * @param {EventHubClient} client                            The EventHub client.
     * @param {string} partitionId                               Partition ID from which to receive.
     * @param {ReceiveOptions} [options]                         Receiver options.
     */
    constructor(context, partitionId, options) {
        super(context, { partitionId: partitionId, name: options ? options.name : undefined });
        /**
         * @property {number} [prefetchCount] The number of messages that the receiver can fetch/receive
         * initially. Defaults to 1000.
         */
        this.prefetchCount = amqp_common_1.Constants.defaultPrefetchCount;
        /**
         * @property {boolean} receiverRuntimeMetricEnabled Indicates whether receiver runtime metric
         * is enabled. Default: false.
         */
        this.receiverRuntimeMetricEnabled = false;
        if (!options)
            options = {};
        this.consumerGroup = options.consumerGroup ? options.consumerGroup : amqp_common_1.Constants.defaultConsumerGroup;
        this.address = `${this._context.config.entityPath}/ConsumerGroups/${this.consumerGroup}/Partitions/${this.partitionId}`;
        this.audience = `${this._context.config.endpoint}${this.address}`;
        this.prefetchCount = options.prefetchCount != undefined ? options.prefetchCount : amqp_common_1.Constants.defaultPrefetchCount;
        this.epoch = options.epoch;
        this.identifier = options.identifier;
        this.options = options;
        this.receiverRuntimeMetricEnabled = options.enableReceiverRuntimeMetric || false;
        this.runtimeInfo = {
            partitionId: `${partitionId}`
        };
        this._checkpoint = {
            enqueuedTimeUtc: new Date(),
            offset: "0",
            sequenceNumber: -1
        };
        this._onAmqpMessage = (context) => {
            const evData = eventData_1.EventData.fromAmqpMessage(context.message);
            evData.body = this._context.dataTransformer.decode(context.message.body);
            this._checkpoint = {
                enqueuedTimeUtc: evData.enqueuedTimeUtc,
                offset: evData.offset,
                sequenceNumber: evData.sequenceNumber
            };
            if (this.receiverRuntimeMetricEnabled && evData) {
                this.runtimeInfo.lastSequenceNumber = evData.lastSequenceNumber;
                this.runtimeInfo.lastEnqueuedTimeUtc = evData.lastEnqueuedTime;
                this.runtimeInfo.lastEnqueuedOffset = evData.lastEnqueuedOffset;
                this.runtimeInfo.retrievalTime = evData.retrievalTime;
                log.receiver("[%s] RuntimeInfo of Receiver '%s' is %O", this._context.connectionId, this.name, this.runtimeInfo);
            }
            this._onMessage(evData);
        };
        this._onAmqpError = (context) => {
            const receiverError = context.receiver && context.receiver.error;
            if (receiverError) {
                const ehError = amqp_common_1.translate(receiverError);
                log.error("[%s] An error occurred for Receiver '%s': %O.", this._context.connectionId, this.name, ehError);
                if (this._receiver && !this._receiver.isClosed()) {
                    this._onError(ehError);
                }
            }
        };
        this._onSessionError = (context) => {
            const sessionError = context.session && context.session.error;
            if (sessionError) {
                const ehError = amqp_common_1.translate(sessionError);
                log.error("[%s] An error occurred on the session for Receiver '%s': %O.", this._context.connectionId, this.name, ehError);
                if (this._receiver && !this._receiver.isSessionClosed()) {
                    this._onError(ehError);
                }
            }
        };
        this._onAmqpClose = async (context) => {
            const receiverError = context.receiver && context.receiver.error;
            if (receiverError) {
                log.error("[%s] 'receiver_close' event occurred for receiver '%s' with address '%s'. " +
                    "The associated error is: %O", this._context.connectionId, this.name, this.address, receiverError);
            }
            if (this._receiver && !this._receiver.isClosed()) {
                if (!this.isConnecting) {
                    log.error("[%s] 'receiver_close' event occurred on the receiver '%s' with address '%s' " +
                        "and the sdk did not initiate this. The receiver is not reconnecting. Hence, calling " +
                        "detached from the _onAmqpClose() handler.", this._context.connectionId, this.name, this.address);
                    await this.detached(receiverError);
                }
                else {
                    log.error("[%s] 'receiver_close' event occurred on the receiver '%s' with address '%s' " +
                        "and the sdk did not initate this. Moreover the receiver is already re-connecting. " +
                        "Hence not calling detached from the _onAmqpClose() handler.", this._context.connectionId, this.name, this.address);
                }
            }
            else {
                log.error("[%s] 'receiver_close' event occurred on the receiver '%s' with address '%s' " +
                    "because the sdk initiated it. Hence not calling detached from the _onAmqpClose" +
                    "() handler.", this._context.connectionId, this.name, this.address);
            }
        };
        this._onSessionClose = async (context) => {
            const sessionError = context.session && context.session.error;
            if (sessionError) {
                log.error("[%s] 'session_close' event occurred for receiver '%s' with address '%s'. " +
                    "The associated error is: %O", this._context.connectionId, this.name, this.address, sessionError);
            }
            if (this._receiver && !this._receiver.isSessionClosed()) {
                if (!this.isConnecting) {
                    log.error("[%s] 'session_close' event occurred on the session of receiver '%s' with " +
                        "address '%s' and the sdk did not initiate this. Hence calling detached from the " +
                        "_onSessionClose() handler.", this._context.connectionId, this.name, this.address);
                    await this.detached(sessionError);
                }
                else {
                    log.error("[%s] 'session_close' event occurred on the session of receiver '%s' with " +
                        "address '%s' and the sdk did not initiate this. Moreover the receiver is already " +
                        "re-connecting. Hence not calling detached from the _onSessionClose() handler.", this._context.connectionId, this.name, this.address);
                }
            }
            else {
                log.error("[%s] 'session_close' event occurred on the session of receiver '%s' with address " +
                    "'%s' because the sdk initiated it. Hence not calling detached from the _onSessionClose" +
                    "() handler.", this._context.connectionId, this.name, this.address);
            }
        };
    }
    /**
     * Will reconnect the receiver link if necessary.
     * @ignore
     * @param {AmqpError | Error} [receiverError] The receiver error if any.
     * @returns {Promise<void>} Promise<void>.
     */
    async detached(receiverError) {
        try {
            const wasCloseInitiated = this._receiver && this._receiver.isClosed();
            // Clears the token renewal timer. Closes the link and its session if they are open.
            // Removes the link and its session if they are present in rhea's cache.
            await this._closeLink(this._receiver);
            // For session_close and receiver_close this should attempt to reopen
            // only when the receiver(sdk) did not initiate the close) OR
            // if an error is present and the error is retryable.
            let shouldReopen = false;
            if (receiverError && !wasCloseInitiated) {
                const translatedError = amqp_common_1.translate(receiverError);
                if (translatedError.retryable) {
                    shouldReopen = true;
                    log.error("[%s] close() method of Receiver '%s' with address '%s' was not called. There " +
                        "was an accompanying error and it is retryable. This is a candidate for re-establishing " +
                        "the receiver link.", this._context.connectionId, this.name, this.address);
                }
                else {
                    log.error("[%s] close() method of Receiver '%s' with address '%s' was not called. There " +
                        "was an accompanying error and it is NOT retryable. Hence NOT re-establishing " +
                        "the receiver link.", this._context.connectionId, this.name, this.address);
                }
            }
            else if (!wasCloseInitiated) {
                shouldReopen = true;
                log.error("[%s] close() method of Receiver '%s' with address '%s' was not called. " +
                    "There was no accompanying error as well. This is a candidate for re-establishing " +
                    "the receiver link.", this._context.connectionId, this.name, this.address);
            }
            else {
                const state = {
                    wasCloseInitiated: wasCloseInitiated,
                    receiverError: receiverError,
                    _receiver: this._receiver
                };
                log.error("[%s] Something is busted. State of Receiver '%s' with address '%s' is: %O", this._context.connectionId, this.name, this.address, state);
            }
            if (shouldReopen) {
                const rcvrOptions = {
                    onMessage: this._onAmqpMessage,
                    onError: this._onAmqpError,
                    onClose: this._onAmqpClose,
                    onSessionError: this._onSessionError,
                    onSessionClose: this._onSessionClose,
                    newName: true // provide a new name to the link while re-connecting it. This ensures that
                    // the service does not send an error stating that the link is still open.
                };
                // reconnect the receiver link with sequenceNumber of the last received message as the offset
                // if messages were received by the receiver before it got disconnected.
                if (this._checkpoint.sequenceNumber > -1) {
                    rcvrOptions.eventPosition = eventPosition_1.EventPosition.fromSequenceNumber(this._checkpoint.sequenceNumber);
                }
                const options = this._createReceiverOptions(rcvrOptions);
                // shall retry forever at an interval of 15 seconds if the error is a retryable error
                // else bail out when the error is not retryable or the oepration succeeds.
                const config = {
                    operation: () => this._init(options),
                    connectionId: this._context.connectionId,
                    operationType: amqp_common_1.RetryOperationType.receiverLink,
                    times: amqp_common_1.Constants.defaultConnectionRetryAttempts,
                    delayInSeconds: 15
                };
                await amqp_common_1.retry(config);
            }
        }
        catch (err) {
            log.error("[%s] An error occurred while processing detached() of Receiver '%s' with address " +
                "'%s': %O", this._context.connectionId, this.name, this.address, err);
        }
    }
    /**
     * Closes the underlying AMQP receiver.
     * @ignore
     * @returns {Promise<void>}
     */
    async close() {
        if (this._receiver) {
            const receiverLink = this._receiver;
            this._deleteFromCache();
            await this._closeLink(receiverLink);
        }
    }
    /**
     * Determines whether the AMQP receiver link is open. If open then returns true else returns false.
     * @ignore
     * @return {boolean} boolean
     */
    isOpen() {
        const result = this._receiver && this._receiver.isOpen();
        log.error("[%s] Receiver '%s' with address '%s' is open? -> %s", this._context.connectionId, this.name, this.address, result);
        return result;
    }
    _deleteFromCache() {
        this._receiver = undefined;
        delete this._context.receivers[this.name];
        log.error("[%s] Deleted the receiver '%s' from the client cache.", this._context.connectionId, this.name);
    }
    /**
     * Creates a new AMQP receiver under a new AMQP session.
     * @ignore
     * @returns {Promise<void>}
     */
    async _init(options) {
        try {
            if (!this.isOpen() && !this.isConnecting) {
                log.error("[%s] The receiver '%s' with address '%s' is not open and is not currently " +
                    "establishing itself. Hence let's try to connect.", this._context.connectionId, this.name, this.address);
                this.isConnecting = true;
                await this._negotiateClaim();
                if (!options) {
                    options = this._createReceiverOptions({
                        onMessage: this._onAmqpMessage,
                        onError: this._onAmqpError,
                        onClose: this._onAmqpClose,
                        onSessionError: this._onSessionError,
                        onSessionClose: this._onSessionClose,
                    });
                }
                log.error("[%s] Trying to create receiver '%s' with options %O", this._context.connectionId, this.name, options);
                this._receiver = await this._context.connection.createReceiver(options);
                this.isConnecting = false;
                log.error("[%s] Receiver '%s' with address '%s' has established itself.", this._context.connectionId, this.name, this.address);
                log.receiver("Promise to create the receiver resolved. Created receiver with name: ", this.name);
                log.receiver("[%s] Receiver '%s' created with receiver options: %O", this._context.connectionId, this.name, options);
                // It is possible for someone to close the receiver and then start it again.
                // Thus make sure that the receiver is present in the client cache.
                if (!this._context.receivers[this.name])
                    this._context.receivers[this.name] = this;
                await this._ensureTokenRenewal();
            }
            else {
                log.error("[%s] The receiver '%s' with address '%s' is open -> %s and is connecting " +
                    "-> %s. Hence not reconnecting.", this._context.connectionId, this.name, this.address, this.isOpen(), this.isConnecting);
            }
        }
        catch (err) {
            this.isConnecting = false;
            err = amqp_common_1.translate(err);
            log.error("[%s] An error occured while creating the receiver '%s': %O", this._context.connectionId, this.name, err);
            throw err;
        }
    }
    /**
     * Creates the options that need to be specified while creating an AMQP receiver link.
     * @ignore
     */
    _createReceiverOptions(options) {
        if (options.newName)
            this.name = `${uuid()}`;
        const rcvrOptions = {
            name: this.name,
            autoaccept: true,
            source: {
                address: this.address
            },
            credit_window: this.prefetchCount,
            onMessage: options.onMessage || this._onAmqpMessage,
            onError: options.onError || this._onAmqpError,
            onClose: options.onClose || this._onAmqpClose,
            onSessionError: options.onSessionError || this._onSessionError,
            onSessionClose: options.onSessionClose || this._onSessionClose
        };
        if (this.epoch !== undefined && this.epoch !== null) {
            if (!rcvrOptions.properties)
                rcvrOptions.properties = {};
            rcvrOptions.properties[amqp_common_1.Constants.attachEpoch] = rhea_promise_1.types.wrap_long(this.epoch);
        }
        if (this.identifier) {
            if (!rcvrOptions.properties)
                rcvrOptions.properties = {};
            rcvrOptions.properties[amqp_common_1.Constants.receiverIdentifierName] = this.identifier;
        }
        if (this.receiverRuntimeMetricEnabled) {
            rcvrOptions.desired_capabilities = amqp_common_1.Constants.enableReceiverRuntimeMetricName;
        }
        const eventPosition = options.eventPosition || this.options.eventPosition;
        if (eventPosition) {
            // Set filter on the receiver if event position is specified.
            const filterClause = eventPosition.getExpression();
            if (filterClause) {
                rcvrOptions.source.filter = {
                    "apache.org:selector-filter:string": rhea_promise_1.types.wrap_described(filterClause, 0x468C00000004)
                };
            }
        }
        return rcvrOptions;
    }
}
exports.EventHubReceiver = EventHubReceiver;
//# sourceMappingURL=eventHubReceiver.js.map