"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const uuid = require("uuid/v4");
const amqp_common_1 = require("./amqp-common");
const rhea_promise_1 = require("./rhea-promise");
const linkEntity_1 = require("./linkEntity");
const log = require("./log");
/**
 * @class ManagementClient
 * @ignore
 * Descibes the EventHubs Management Client that talks
 * to the $management endpoint over AMQP connection.
 */
class ManagementClient extends linkEntity_1.LinkEntity {
    /**
     * Instantiates the management client.
     * @constructor
     * @ignore
     * @param {BaseConnectionContext} context The connection context.
     * @param {string} [address] The address for the management endpoint. For IotHub it will be
     * `/messages/events/$management`.
     */
    constructor(context, options) {
        super(context, {
            address: options && options.address ? options.address : amqp_common_1.Constants.management,
            audience: options && options.audience
                ? options.audience
                : `${context.config.endpoint}${context.config.entityPath}/$management`
        });
        this.managementLock = `${amqp_common_1.Constants.managementRequestKey}-${uuid()}`;
        /**
         * @property {string} replyTo The reply to Guid for the management client.
         */
        this.replyTo = uuid();
        this._context = context;
        this.entityPath = context.config.entityPath;
    }
    /**
     * Provides the eventhub runtime information.
     * @ignore
     * @param {Connection} connection - The established amqp connection
     * @returns {Promise<EventHubRuntimeInformation>}
     */
    async getHubRuntimeInformation() {
        const info = await this._makeManagementRequest(amqp_common_1.Constants.eventHub);
        const runtimeInfo = {
            path: info.name,
            createdAt: new Date(info.created_at),
            partitionCount: info.partition_count,
            partitionIds: info.partition_ids,
            type: info.type
        };
        log.mgmt("[%s] The hub runtime info is: %O", this._context.connectionId, runtimeInfo);
        return runtimeInfo;
    }
    /**
     * Provides an array of partitionIds.
     * @ignore
     * @param {Connection} connection - The established amqp connection
     * @returns {Promise<Array<string>>}
     */
    async getPartitionIds() {
        const runtimeInfo = await this.getHubRuntimeInformation();
        return runtimeInfo.partitionIds;
    }
    /**
     * Provides information about the specified partition.
     * @ignore
     * @param {Connection} connection - The established amqp connection
     * @param {(string|number)} partitionId Partition ID for which partition information is required.
     */
    async getPartitionInformation(partitionId) {
        if (!partitionId ||
            (partitionId && typeof partitionId !== "string" && typeof partitionId !== "number")) {
            throw new Error("'partitionId' is a required parameter and must be of " +
                "type: 'string' | 'number'.");
        }
        const info = await this._makeManagementRequest(amqp_common_1.Constants.partition, partitionId);
        const partitionInfo = {
            beginningSequenceNumber: info.begin_sequence_number,
            hubPath: info.name,
            lastEnqueuedOffset: info.last_enqueued_offset,
            lastEnqueuedTimeUtc: new Date(info.last_enqueued_time_utc),
            lastSequenceNumber: info.last_enqueued_sequence_number,
            partitionId: info.partition,
            type: info.type
        };
        log.mgmt("[%s] The partition info is: %O.", this._context.connectionId, partitionInfo);
        return partitionInfo;
    }
    /**
     * Closes the AMQP management session to the Event Hub for this client,
     * returning a promise that will be resolved when disconnection is completed.
     * @ignore
     * @return {Promise<void>}
     */
    async close() {
        try {
            if (this._isMgmtRequestResponseLinkOpen()) {
                const mgmtLink = this._mgmtReqResLink;
                this._mgmtReqResLink = undefined;
                clearTimeout(this._tokenRenewalTimer);
                await mgmtLink.close();
                log.mgmt("Successfully closed the management session.");
            }
        }
        catch (err) {
            const msg = `An error occurred while closing the management session: ${err}`;
            log.error(msg);
            throw new Error(msg);
        }
    }
    async _init() {
        try {
            if (!this._isMgmtRequestResponseLinkOpen()) {
                await this._negotiateClaim();
                const rxopt = {
                    source: { address: this.address },
                    name: this.replyTo,
                    target: { address: this.replyTo },
                    onSessionError: (context) => {
                        const id = context.connection.options.id;
                        const ehError = amqp_common_1.translate(context.session.error);
                        log.error("[%s] An error occurred on the session for request/response links for " +
                            "$management: %O", id, ehError);
                    }
                };
                const sropt = { target: { address: this.address } };
                log.mgmt("[%s] Creating sender/receiver links on a session for $management endpoint.", this._context.connectionId);
                this._mgmtReqResLink =
                    await amqp_common_1.RequestResponseLink.create(this._context.connection, sropt, rxopt);
                this._mgmtReqResLink.sender.registerHandler(rhea_promise_1.SenderEvents.senderError, (context) => {
                    const id = context.connection.options.id;
                    const ehError = amqp_common_1.translate(context.sender.error);
                    log.error("[%s] An error occurred on the $management sender link.. %O", id, ehError);
                });
                this._mgmtReqResLink.receiver.registerHandler(rhea_promise_1.ReceiverEvents.receiverError, (context) => {
                    const id = context.connection.options.id;
                    const ehError = amqp_common_1.translate(context.receiver.error);
                    log.error("[%s] An error occurred on the $management receiver link.. %O", id, ehError);
                });
                log.mgmt("[%s] Created sender '%s' and receiver '%s' links for $management endpoint.", this._context.connectionId, this._mgmtReqResLink.sender.name, this._mgmtReqResLink.receiver.name);
                await this._ensureTokenRenewal();
            }
        }
        catch (err) {
            err = amqp_common_1.translate(err);
            log.error("[%s] An error occured while establishing the $management links: %O", this._context.connectionId, err);
            throw err;
        }
    }
    /**
     * @private
     * Helper method to make the management request
     * @param {Connection} connection - The established amqp connection
     * @param {string} type - The type of entity requested for. Valid values are "eventhub", "partition"
     * @param {string | number} [partitionId] - The partitionId. Required only when type is "partition".
     */
    async _makeManagementRequest(type, partitionId) {
        if (partitionId && typeof partitionId !== "string" && typeof partitionId !== "number") {
            throw new Error("'partitionId' is a required parameter and must be of type: 'string' | 'number'.");
        }
        try {
            const request = {
                body: Buffer.from(JSON.stringify([])),
                message_id: uuid(),
                reply_to: this.replyTo,
                application_properties: {
                    operation: amqp_common_1.Constants.readOperation,
                    name: this.entityPath,
                    type: `${amqp_common_1.Constants.vendorString}:${type}`
                }
            };
            if (partitionId && type === amqp_common_1.Constants.partition) {
                request.application_properties.partition = partitionId;
            }
            log.mgmt("[%s] Acquiring lock to get the management req res link.", this._context.connectionId);
            await amqp_common_1.defaultLock.acquire(this.managementLock, () => { return this._init(); });
            return await this._mgmtReqResLink.sendRequest(request);
        }
        catch (err) {
            err = amqp_common_1.translate(err);
            log.error("An error occurred while making the request to $management endpoint: %O", err);
            throw err;
        }
    }
    _isMgmtRequestResponseLinkOpen() {
        return this._mgmtReqResLink && this._mgmtReqResLink.isOpen();
    }
}
exports.ManagementClient = ManagementClient;
//# sourceMappingURL=managementClient.js.map